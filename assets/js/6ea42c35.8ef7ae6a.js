"use strict";(self.webpackChunkwasmbox_docs=self.webpackChunkwasmbox_docs||[]).push([[144],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),u=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=u(e.components);return r.createElement(s.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(t),m=a,h=p["".concat(s,".").concat(m)]||p[m]||d[m]||o;return t?r.createElement(h,i(i({ref:n},c),{},{components:t})):r.createElement(h,i({ref:n},c))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[p]="string"==typeof e?e:a,i[1]=l;for(var u=2;u<o;u++)i[u]=t[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},131:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var r=t(7462),a=(t(7294),t(3905));const o={title:"Async WASM",sidebar_position:4},i=void 0,l={unversionedId:"advanced/asyncify",id:"advanced/asyncify",title:"Async WASM",description:"Standard WASM execution is synchronous - a function is called, some computation happens and eventually a result it returned. This model does not work well for longer running programs which may need to wait for an event to happen (e.g. IVirtualEventPoll).",source:"@site/docs/advanced/asyncify.md",sourceDirName:"advanced",slug:"/advanced/asyncify",permalink:"/wasmbox/advanced/asyncify",draft:!1,editUrl:"https://github.com/Placeholder-Software/Wasmbox/tree/master/docs/advanced/asyncify.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Async WASM",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Custom WASM Instantiation",permalink:"/wasmbox/advanced/manual_loading"},next:{title:"Reference",permalink:"/wasmbox/reference/"}},s={},u=[{value:"Calling Async WASM",id:"calling-async-wasm",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Unity Job System",id:"unity-job-system",level:2},{value:"Caveats",id:"caveats",level:2},{value:"No Concurrency",id:"no-concurrency",level:3},{value:"Single Result",id:"single-result",level:3},{value:"Void",id:"void",level:3}],c={toc:u};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Standard WASM execution is synchronous - a function is called, some computation happens and eventually a result it returned. This model does not work well for longer running programs which may need to wait for an event to happen (e.g. ",(0,a.kt)("a",{parentName:"p",href:"/wasmbox/reference/code/WASI/poll#"},"IVirtualEventPoll"),")."),(0,a.kt)("p",null,"Async WASM transforms a synchronous program into an asynchronous program which can have execution suspended and resumed later. This allows a single function call to be spread across multiple frames. While a call is suspended it consumes no CPU resources."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},'Enable async WASM by checking "asyncify" in the ',(0,a.kt)("a",{parentName:"p",href:"/wasmbox/reference/editor/import#3-transformation"},"importer"),".")),(0,a.kt)("h2",{id:"calling-async-wasm"},"Calling Async WASM"),(0,a.kt)("p",null,"When a WASM function is transformed into an async WASM call this changes the value returned from the autogenerated wrapper code. Instead of return type ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," the function will now return a ",(0,a.kt)("a",{parentName:"p",href:"/wasmbox/reference/code/future"},(0,a.kt)("inlineCode",{parentName:"a"},"Future<T>")),", which allows you to resume execution repeatedly until a result is produced."),(0,a.kt)("p",null,"The model is very similar to a Unity coroutine, where yielding allows you to delay execution of a method for one frame. Futures can be used in a coroutine:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Async WASM Coroutine"',title:'"Async',WASM:!0,'Coroutine"':!0},"// Call the function like normal\nvar future = Wrapper.run_example_method(1, 2, 3, 4);\n\n// Resume execution every frame until it is completed\nwhile (!future.TryComplete(out var result))\n{\n    future.Resume();\n    yield return null;\n}\n\n// Do something with the final return result\nDebug.Log(result);\n")),(0,a.kt)("h2",{id:"error-handling"},"Error Handling"),(0,a.kt)("p",null,"Wasmbox supports two types of error handling: ",(0,a.kt)("a",{parentName:"p",href:"/wasmbox/reference/code/codegeneration#trap-handling"},"exceptions and results"),", both are supported by async wasm. If results are in use then the ",(0,a.kt)("inlineCode",{parentName:"p"},"Future<T>")," will return the result container from ",(0,a.kt)("inlineCode",{parentName:"p"},"TryComplete"),". If exceptions are in use then the exception will be ",(0,a.kt)("strong",{parentName:"p"},"thrown")," when ",(0,a.kt)("inlineCode",{parentName:"p"},"TryComplete")," is called."),(0,a.kt)("h2",{id:"unity-job-system"},"Unity Job System"),(0,a.kt)("p",null,"A ",(0,a.kt)("a",{parentName:"p",href:"/wasmbox/reference/code/future"},(0,a.kt)("inlineCode",{parentName:"a"},"Future<T>"))," cannot be passed into a job. It can be converted into a ",(0,a.kt)("a",{parentName:"p",href:"/wasmbox/reference/code/futurerunner"},(0,a.kt)("inlineCode",{parentName:"a"},"FutureRunner<T>"))," by calling ",(0,a.kt)("inlineCode",{parentName:"p"},".ToJob()"),", this can be passed into a custom job."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"A ",(0,a.kt)("inlineCode",{parentName:"p"},"FutureRunner<T>")," cannot be used to retrieve a result. Once ",(0,a.kt)("inlineCode",{parentName:"p"},"Resume()")," has returned ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," inside a Job then ",(0,a.kt)("inlineCode",{parentName:"p"},"TryGetResult")," can be called back on the original ",(0,a.kt)("inlineCode",{parentName:"p"},"Future<T>")," (on the main thread).")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Async Job Coroutine"',title:'"Async',Job:!0,'Coroutine"':!0},"// Call the function like normal\nvar future = Wrapper.run_example_method(1, 2, 3, 4);\n\n// Finish the future in jobs\nyield return future.ToJob()\n\n// Do something with the final return result\nfuture.TryComplete(out var result);\nDebug.Log(result);\n")),(0,a.kt)("h2",{id:"caveats"},"Caveats"),(0,a.kt)("h3",{id:"no-concurrency"},"No Concurrency"),(0,a.kt)("p",null,"When using async WASM a given wrapper may only have one async call running at once! It would be possible to have two calls suspended at once, but it would introduce concurrency bugs in WASM which was not specifically designed to handle it, so it is not allowed by Wasmbox. ",(0,a.kt)("strong",{parentName:"p"},"The following code will throw an exception"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Don\'t Do This!"',title:"\"Don't",Do:!0,'This!"':!0},"var future1 = Wrapper.run_example_method(1, 2, 3, 4);\nvar future2 = Wrapper.run_example_method(4, 3, 2, 1); // This will throw an `InvalidOperationException`\n")),(0,a.kt)("h3",{id:"single-result"},"Single Result"),(0,a.kt)("p",null,"When a result is retrieved by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"Future<T>.TryComplete")," the memory backing that future is internally cleaned up. All calls to ",(0,a.kt)("inlineCode",{parentName:"p"},"Resume")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"TryComplete")," after this will throw an ",(0,a.kt)("inlineCode",{parentName:"p"},"InvalidOperationException"),". ",(0,a.kt)("strong",{parentName:"p"},"The following code will throw an exception"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Don\'t Do This!"',title:"\"Don't",Do:!0,'This!"':!0},"// Call an async method\nvar future = Wrapper.run_example_method(1, 2, 3, 4);\n\n// Wait for it to complete\nyield return future;\n\n// Get the result\nfuture.TryComplete(out var result);\nDebug.Log(result);\n\n// These will throw an `InvalidOperationException`\nfuture.TryComplete(out var result); \nfuture.Resume();\n")),(0,a.kt)("h3",{id:"void"},"Void"),(0,a.kt)("p",null,"Methods which return nothing (i.e. ",(0,a.kt)("inlineCode",{parentName:"p"},"void"),") will return ",(0,a.kt)("inlineCode",{parentName:"p"},"Future<Void>")," when converted to async. ",(0,a.kt)("inlineCode",{parentName:"p"},"Void")," is an empty struct which contains nothing."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="This is fine!"',title:'"This',is:!0,'fine!"':!0},"// Call an async method\nvar future = Wrapper.this_returns_void(1, 2, 3, 4);\n\n// Wait for it to complete\nyield return future;\n\n// Get the \"result\", you can't do anything with it because it represents nothing, but it's there!\nfuture.TryComplete(out var result);\n")))}p.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkwasmbox_docs=self.webpackChunkwasmbox_docs||[]).push([[2465],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=d(e,["components","mdxType","originalType","parentName"]),p=s(n),g=i,u=p["".concat(l,".").concat(g)]||p[g]||c[g]||r;return n?a.createElement(u,o(o({ref:t},m),{},{components:n})):a.createElement(u,o({ref:t},m))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=g;var d={};for(var l in t)hasOwnProperty.call(t,l)&&(d[l]=t[l]);d.originalType=e,d[p]="string"==typeof e?e:i,o[1]=d;for(var s=2;s<r;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},6783:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>d,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const r={title:"Memory"},o=void 0,d={unversionedId:"reference/code/wasmtime/memory",id:"reference/code/wasmtime/memory",title:"Memory",description:"A Memory represents a contiguous array of bytes that WASM code can read and write. The Memory class is a wrapper around the wasmtime::Memory struct.",source:"@site/docs/reference/code/wasmtime/memory.md",sourceDirName:"reference/code/wasmtime",slug:"/reference/code/wasmtime/memory",permalink:"/wasmbox/reference/code/wasmtime/memory",draft:!1,editUrl:"https://github.com/Placeholder-Software/Wasmbox/tree/master/docs/reference/code/wasmtime/memory.md",tags:[],version:"current",frontMatter:{title:"Memory"},sidebar:"tutorialSidebar",previous:{title:"Linker",permalink:"/wasmbox/reference/code/wasmtime/linker"},next:{title:"Module",permalink:"/wasmbox/reference/code/wasmtime/module"}},l={},s=[{value:"Properties",id:"properties",level:2},{value:"<code>long PageSize</code>",id:"long-pagesize",level:3},{value:"<code>long Minimum</code>",id:"long-minimum",level:3},{value:"<code>long? Maximum</code>",id:"long-maximum",level:3},{value:"<code>bool Is64Bit</code>",id:"bool-is64bit",level:3},{value:"Methods",id:"methods",level:2},{value:"Size",id:"size",level:3},{value:"<code>long GetSize()</code>",id:"long-getsize",level:4},{value:"<code>long GetLength()</code>",id:"long-getlength",level:4},{value:"<code>Grow(long delta)</code>",id:"growlong-delta",level:4},{value:"Read/Write",id:"readwrite",level:3},{value:"<code>Read&lt;T&gt;(long address)</code>/<code>Write&lt;T&gt;(long address, T value)</code>",id:"readtlong-addresswritetlong-address-t-value",level:4},{value:"<code>ReadString(long address, int length)</code>",id:"readstringlong-address-int-length",level:4},{value:"<code>WriteString(long address, string value)</code>",id:"writestringlong-address-string-value",level:4},{value:"<code>ReadNullTerminatedString(long address)</code>",id:"readnullterminatedstringlong-address",level:4},{value:"<code>ReadDouble</code>/<code>WriteDouble</code>",id:"readdoublewritedouble",level:4},{value:"<code>ReadSingle</code>/<code>WriteSingle</code>",id:"readsinglewritesingle",level:4},{value:"<code>ReadIntPtr</code>/<code>WriteIntPtr</code>",id:"readintptrwriteintptr",level:4},{value:"<code>ReadInt64</code>/<code>WriteInt64</code>",id:"readint64writeint64",level:4},{value:"<code>ReadInt32</code>/<code>WriteInt32</code>",id:"readint32writeint32",level:4},{value:"<code>ReadInt16</code>/<code>WriteInt16</code>",id:"readint16writeint16",level:4},{value:"<code>ReadByte</code>/<code>WriteByte</code>",id:"readbytewritebyte",level:4},{value:"Get Pointer",id:"get-pointer",level:3},{value:"<code>unsafe IntPtr GetPointer()</code>",id:"unsafe-intptr-getpointer",level:3},{value:"<code>Span&lt;byte&gt; GetSpan(long address, int length)</code>",id:"spanbyte-getspanlong-address-int-length",level:3},{value:"<code>Span&lt;byte&gt; GetSpan(long address)</code>",id:"spanbyte-getspanlong-address",level:3},{value:"<code>Span&lt;T&gt; GetSpan&lt;T&gt;(long address, int length)</code>",id:"spant-getspantlong-address-int-length",level:3}],m={toc:s};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Memory")," represents a contiguous array of bytes that WASM code can read and write. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Memory")," class is a wrapper around the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html"},(0,i.kt)("inlineCode",{parentName:"a"},"wasmtime::Memory"))," struct."),(0,i.kt)("h2",{id:"properties"},"Properties"),(0,i.kt)("h3",{id:"long-pagesize"},(0,i.kt)("inlineCode",{parentName:"h3"},"long PageSize")),(0,i.kt)("p",null,"Get the number of bytes in a page of memory."),(0,i.kt)("h3",{id:"long-minimum"},(0,i.kt)("inlineCode",{parentName:"h3"},"long Minimum")),(0,i.kt)("p",null,"Get the minimum size of this memory in pages. The memory will always be at least ",(0,i.kt)("inlineCode",{parentName:"p"},"Minimum * PageSize")," bytes in size."),(0,i.kt)("h3",{id:"long-maximum"},(0,i.kt)("inlineCode",{parentName:"h3"},"long? Maximum")),(0,i.kt)("p",null,"Get the maximum size of this memory in pages, or ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," if there is no maximum."),(0,i.kt)("h3",{id:"bool-is64bit"},(0,i.kt)("inlineCode",{parentName:"h3"},"bool Is64Bit")),(0,i.kt)("p",null,"Check if this memory represents a 64 bit memory (capable of representing more than 4GB)."),(0,i.kt)("h2",{id:"methods"},"Methods"),(0,i.kt)("h3",{id:"size"},"Size"),(0,i.kt)("h4",{id:"long-getsize"},(0,i.kt)("inlineCode",{parentName:"h4"},"long GetSize()")),(0,i.kt)("p",null,"Get the current size of this memory in pages."),(0,i.kt)("h4",{id:"long-getlength"},(0,i.kt)("inlineCode",{parentName:"h4"},"long GetLength()")),(0,i.kt)("p",null,"Get the current size of this memory in bytes."),(0,i.kt)("h4",{id:"growlong-delta"},(0,i.kt)("inlineCode",{parentName:"h4"},"Grow(long delta)")),(0,i.kt)("p",null,"Grow the memory by ",(0,i.kt)("inlineCode",{parentName:"p"},"delta")," pages."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"This will invalidate any pointers or spans which refer to this memory.")),(0,i.kt)("h3",{id:"readwrite"},"Read/Write"),(0,i.kt)("h4",{id:"readtlong-addresswritetlong-address-t-value"},(0,i.kt)("inlineCode",{parentName:"h4"},"Read<T>(long address)"),"/",(0,i.kt)("inlineCode",{parentName:"h4"},"Write<T>(long address, T value)")),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"WebAssembly is always ",(0,i.kt)("strong",{parentName:"p"},"little endian"),", on big endian platforms numeric values must be converted accordingly.")),(0,i.kt)("p",null,"Read or write an ",(0,i.kt)("inlineCode",{parentName:"p"},"unmanaged")," object of type ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," from the given address."),(0,i.kt)("h4",{id:"readstringlong-address-int-length"},(0,i.kt)("inlineCode",{parentName:"h4"},"ReadString(long address, int length)")),(0,i.kt)("p",null,"Read a string starting at the given address, with the given length in bytes. Defaults to UTF8 encoding."),(0,i.kt)("h4",{id:"writestringlong-address-string-value"},(0,i.kt)("inlineCode",{parentName:"h4"},"WriteString(long address, string value)")),(0,i.kt)("p",null,"Write a string to the given address. Defaults to UTF8 encoding."),(0,i.kt)("h4",{id:"readnullterminatedstringlong-address"},(0,i.kt)("inlineCode",{parentName:"h4"},"ReadNullTerminatedString(long address)")),(0,i.kt)("p",null,"Read bytes starting at address until a zero is encountered, interprets those bytes as a UTF8 string."),(0,i.kt)("h4",{id:"readdoublewritedouble"},(0,i.kt)("inlineCode",{parentName:"h4"},"ReadDouble"),"/",(0,i.kt)("inlineCode",{parentName:"h4"},"WriteDouble")),(0,i.kt)("p",null,"Read or write a ",(0,i.kt)("inlineCode",{parentName:"p"},"double")," to the given address, automatically converting endianness if necessary."),(0,i.kt)("h4",{id:"readsinglewritesingle"},(0,i.kt)("inlineCode",{parentName:"h4"},"ReadSingle"),"/",(0,i.kt)("inlineCode",{parentName:"h4"},"WriteSingle")),(0,i.kt)("p",null,"Read or write a ",(0,i.kt)("inlineCode",{parentName:"p"},"float")," to the given address, automatically converting endianness if necessary."),(0,i.kt)("h4",{id:"readintptrwriteintptr"},(0,i.kt)("inlineCode",{parentName:"h4"},"ReadIntPtr"),"/",(0,i.kt)("inlineCode",{parentName:"h4"},"WriteIntPtr")),(0,i.kt)("p",null,"Read or write an ",(0,i.kt)("inlineCode",{parentName:"p"},"IntPtr")," (4 bytes or 8 bytes, depending on the host platform), automatically converting endianness if necessary."),(0,i.kt)("h4",{id:"readint64writeint64"},(0,i.kt)("inlineCode",{parentName:"h4"},"ReadInt64"),"/",(0,i.kt)("inlineCode",{parentName:"h4"},"WriteInt64")),(0,i.kt)("p",null,"Read or write a ",(0,i.kt)("inlineCode",{parentName:"p"},"long")," to the given address, automatically converting endianness if necessary."),(0,i.kt)("h4",{id:"readint32writeint32"},(0,i.kt)("inlineCode",{parentName:"h4"},"ReadInt32"),"/",(0,i.kt)("inlineCode",{parentName:"h4"},"WriteInt32")),(0,i.kt)("p",null,"Read or write a ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," to the given address, automatically converting endianness if necessary."),(0,i.kt)("h4",{id:"readint16writeint16"},(0,i.kt)("inlineCode",{parentName:"h4"},"ReadInt16"),"/",(0,i.kt)("inlineCode",{parentName:"h4"},"WriteInt16")),(0,i.kt)("p",null,"Read or write a ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," to the given address, automatically converting endianness if necessary."),(0,i.kt)("h4",{id:"readbytewritebyte"},(0,i.kt)("inlineCode",{parentName:"h4"},"ReadByte"),"/",(0,i.kt)("inlineCode",{parentName:"h4"},"WriteByte")),(0,i.kt)("p",null,"Read or write a ",(0,i.kt)("inlineCode",{parentName:"p"},"byte")," to the given address."),(0,i.kt)("h3",{id:"get-pointer"},"Get Pointer"),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"These methods return a pointer/Span which refers directly to the memory. These pointers can become invalid if ",(0,i.kt)("inlineCode",{parentName:"p"},"Grow()")," is called or if any ",(0,i.kt)("inlineCode",{parentName:"p"},"WASM")," is executed."),(0,i.kt)("p",{parentName:"admonition"},"You should always acquire a new pointer/Span when external code executes and never store them.")),(0,i.kt)("h3",{id:"unsafe-intptr-getpointer"},(0,i.kt)("inlineCode",{parentName:"h3"},"unsafe IntPtr GetPointer()")),(0,i.kt)("p",null,"Get a pointer to the start of the memory."),(0,i.kt)("h3",{id:"spanbyte-getspanlong-address-int-length"},(0,i.kt)("inlineCode",{parentName:"h3"},"Span<byte> GetSpan(long address, int length)")),(0,i.kt)("p",null,"Get a span of bytes which points to a section of memory."),(0,i.kt)("h3",{id:"spanbyte-getspanlong-address"},(0,i.kt)("inlineCode",{parentName:"h3"},"Span<byte> GetSpan(long address)")),(0,i.kt)("p",null,"Get a span of bytes which starts at the given address and is as long as possible (4GB or to the end of the memory, whichever is smaller)."),(0,i.kt)("h3",{id:"spant-getspantlong-address-int-length"},(0,i.kt)("inlineCode",{parentName:"h3"},"Span<T> GetSpan<T>(long address, int length)")),(0,i.kt)("p",null,"Get a span which interprets a region of memory as a sequence of ",(0,i.kt)("inlineCode",{parentName:"p"},"unmanaged")," type ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"."))}p.isMDXComponent=!0}}]);